(*
 * Copyright (c) 2009-2012 Anil Madhavapeddy <anil@recoil.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

open Unix

(* wrapper for realpath(2) *)
external realpath : string -> string = "unix_realpath"

(* repeat until End_of_file is raised *)
let repeat_until_eof fn =
   try while true do fn () done
   with End_of_file -> ()

(* Retrieve file extension , if any, or blank string otherwise *)
let get_extension ~file =
  let rec search_dot i =
    if i < 1 || file.[i] = '/' then None
    else if file.[i] = '.' then Some (String.sub file (i+1) (String.length file - i - 1))
    else search_dot (i - 1) in
  search_dot (String.length file - 1)

(* Walk directory and call walkfn on every file that matches extension ext *)
let walk_directory_tree exts walkfn root_dir =
  (* If extension list is empty then let all through, otherwise white list *)
  let filter_ext =
    match exts with
    |[] -> fun _ -> true
    |exts -> fun ext -> List.mem ext exts
  in
  (* Recursive directory walker *)
  let rec walk dir =
    let dh = opendir dir in
    repeat_until_eof (fun () ->
      match readdir dh with
      |"." |".." -> ()
      |f ->
        let n = Filename.concat dir f in
        if Sys.is_directory n then walk n
        else begin
          match get_extension ~file:f with
          |None -> ()
          |Some e ->
            if filter_ext e then
              walkfn root_dir (String.sub n 2 (String.length n - 2))
        end
    );
    closedir dh in
  chdir root_dir;
  walk "."

open Arg
open Printf

let file_info = Hashtbl.create 1

let output_header oc =
  fprintf oc "(* This file has been autogenerated by %s *)\n" Sys.argv.(0);
  fprintf oc "module Internal = struct\n";
  fprintf oc "let file_chunks = function\n"

let output_file oc root name =
  let full_name = Filename.concat root name in
  let stats = Unix.stat full_name in
  let size = stats.Unix.st_size in
  Hashtbl.add file_info name size;
  fprintf oc " | \"%s\" | \"/%s\" -> Some [" (String.escaped name) (String.escaped name);
  let fin = open_in (Filename.concat root name) in
  let buf = Buffer.create size in
  Buffer.add_channel buf fin size;
  let s = Buffer.contents buf in
  close_in fin;
  (* Split the file as a series of chunks, of size up to 4096 (to simulate reading sectors) *)
  let sec = 4096 in (* sector size *)
  let rec consume idx =
     if idx = size then fprintf oc "]\n"; (* EOF *)
     if idx+sec < size then begin
       fprintf oc "\"%s\";\n" (String.escaped (String.sub s idx sec));
       consume (idx+sec);
     end else begin (* final chunk, short *)
       fprintf oc "\"%s\" ]\n" (String.escaped (String.sub s idx (size-idx)));
     end
  in
  consume 0

let output_footer oc =
  fprintf oc " | _ -> None\n";
  fprintf oc "\n";
  fprintf oc "let file_list = [";
  Hashtbl.iter (fun k _ -> fprintf oc "\"%s\"; " (String.escaped k)) file_info;
  fprintf oc " ]\n";
  fprintf oc "let file_exists = function\n";
  Hashtbl.iter (fun name _ ->
    fprintf oc " |\"%s\" |\"/%s\" -> true\n" (String.escaped name) (String.escaped name)
  ) file_info;
  fprintf oc " |_ -> false\n";
  fprintf oc "let size = function\n";
  Hashtbl.iter (fun name size ->
    fprintf oc " |\"%s\" |\"/%s\" -> Some %dL\n" (String.escaped name) (String.escaped name) size
  ) file_info;
  fprintf oc " |_ -> None\n\n";
  fprintf oc "end\n\n"

let output_accessor oc =
  function
  |`Plain ->
    fprintf oc "
exception Error of string

let file_stream = Internal.file_list
let file_exists x = Internal.file_exists x
let size name = Internal.size name
let read name = Internal.file_chunks name
"
  |`Lwt ->
    fprintf oc "
open Lwt

exception Error of string

let file_stream = Lwt_stream.of_list Internal.file_list
let file_exists x = return (Internal.file_exists x)
let size name = return (Internal.size name)

let read name =
  match Internal.file_chunks name with
  |None -> return None
  |Some c ->
     let chunks = ref c in
     return (Some (Lwt_stream.from (fun () ->
       match !chunks with
       |hd :: tl -> 
         chunks := tl;
         return (Some hd)
       |[] -> return None
     )))
"

open Cmdliner

let walker output mode dirs exts =
  let dirs = List.map realpath dirs in
  let oc = open_out output in
  output_header oc;
  List.iter (walk_directory_tree exts (output_file oc)) dirs;
  output_footer oc;
  output_accessor oc mode;
  close_out oc

let _ =
  let dirs = Arg.(non_empty & pos_all dir [] & info [] ~docv:"DIRECTORIES" 
    ~doc:"Directories to recursively walk and crunch.") in
  let output = Arg.(value & opt string "/dev/stdout" & info ["o";"output"] ~docv:"OUTPUT"
    ~doc:"Output file for the OCaml module.") in
  let mode = Arg.(value & opt (enum [("plain",`Plain);("lwt",`Lwt)]) `Lwt & info ["m";"mode"] ~docv:"MODE"
    ~doc:"Interface access mode: 'plain' or 'lwt' (default).") in
  let exts = Arg.(value & opt_all string [] & info ["e";"ext"] ~docv:"VALID EXTENSION" 
    ~doc:"If specified, only these extensions will be included in the crunched output. If not specified, then all files will be crunched into the output module.") in
  let cmd_t = Term.(pure walker $ output $ mode $ dirs $ exts) in
  let info =
    let doc = "Convert a directory structure into a standalone `ramdisk` OCaml module that can serve the file contents without requiring an external filesystem to be present." in
    let man = [ `S "BUGS"; `P "Email bug reports to <cl-mirage@lists.cl.cam.ac.uk>."] in
    Term.info "ocaml-crunch" ~version:"1.0.0" ~doc ~man
  in
  match Term.eval (cmd_t, info) with `Ok x -> x | _ -> exit 1
